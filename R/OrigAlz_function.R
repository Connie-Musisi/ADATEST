#' Perform Permutation-Based Differential Abundance Testing
#'
#' This function computes a test statistic for each taxon in a microbiome dataset using estimated scores.
#' It then performs a permutation test to assess statistical significance and adjusts p-values for false discovery rate (FDR) control.
#'
#' @param simdata_filter A phyloseq object containing filtered microbiome data.
#' @param Train_parest Training parameters for test statistic computation.
#' @param B Integer. Number of permutations to perform (default: 1000).
#' @param p.adjust.method Character. Method for p-value adjustment (default: "BH").
#' @param n1 Integer. Number of samples in group 0 (default: computed from dataset).
#' @param n2 Integer. Number of samples in group 1 (default: computed from dataset).
#'
#' @return A list containing:
#' 	\item{org_scaled}{Scaled original OTU table as a matrix.}
#' 	\item{Org_tax}{Original taxonomy table as a data frame.}
#' 	\item{p}{Vector of unadjusted p-values.}
#' 	\item{p.adjusted}{Vector of adjusted p-values.}
#' 	\item{Stat_Obs}{Observed test statistics.}
#' 	\item{Original_results}{Data frame containing test results, including p-values and adjusted indicators.}
#'
#' @details
#' The function computes the test statistic for each taxon based on estimated scores. 
#' The total sum scaling (TSS)-normalized counts in the original dataset are rescaled before test statistic computation.
#' Permutation-based null distributions are generated by permuting all taxa across the two groups while preserving their dependency structure.
#' The resulting raw p-values are adjusted to control the false discovery rate (FDR) using methods such as Benjamini-Hochberg or Storey's q-values.
#'
#' @import phyloseq
#' @import qvalue
#' @importFrom stats p.adjust
#' @export
Orig_Alz_Perm <- function(simdata_filter, Train_parest, B=1000,
                          p.adjust.method="BH", n1=nrow(org_otu)/2,
                          group_var,
                          group_levels,
                          n2=nrow(org_otu)/2){
  #set.seed(19)
  ############# Analyzing Original data ################
  org_data <- simdata_filter
  Org_tax <- as.data.frame(tax_table(org_data))
  
  if(taxa_are_rows(org_data)){
    org_otu <- t(as.matrix(otu_table(org_data)))
  }else{
    org_otu <- as.matrix(otu_table(org_data))
  }
  samdata <- sample_data(simdata_filter)[,group_var]
  n1 <- sum(samdata == group_levels[1])
  n2 <- sum(samdata == group_levels[2])
  
  
  n.taxa<-nrow(simdata_filter@tax_table)
  
  tmp<-sapply(1:n.taxa, FUN=function(i) {
    d<-Normalize(org_otu[1:n1,i],
                 org_otu[(n1+1):(n1+n2),i])
    return(c(d$sample1,d$sample2))
  })
  otu1<-tmp[1:n1,]
  otu2<-tmp[(n1+1):(n1+n2),]
  otu_scaled<-rbind(otu1,otu2)
  
  
  stat.obs<-Test_Statistic(otu_scaled,Train_parest,B=B)
  set.seed(19)
  # Permutation null distributions
  nd<-matrix(nrow=B,ncol=n.taxa)
  for(i in 1:B) {
    perm_otu<-otu_scaled[sample(1:(n1+n2),(n1+n2),replace = FALSE),]
    nd[i,]<-Test_Statistic(perm_otu,Train_parest,B=B)
  }
  
  p<-sapply(1:n.taxa, function(i) {
    mean(nd[,i]>=stat.obs[i])
  })
  
  
  # P-value adjustment
  if(p.adjust.method == "qvalue"){
    check = tryCatch(qvalue(p=p)$qvalues, error = function(e) {
      return(NULL)
    })
    if(is.null(check)){p.adjusted <- qvalue(p=p,lambda=0)$qvalues}
    else{p.adjusted <-check}
    
  } else {
    p.adjusted <- p.adjust(p, method=p.adjust.method)
  }  
  colnames(stat.obs)<-"stat.obs"
  Original_results <- cbind(stat.obs,Org_tax)
  
  
  ## ----Results----------------------------------------------------------------------------------------------------------
  new_ind <- character(nrow(Original_results))
  new_ind[p.adjusted>=0.05] <- "I_0"
  new_ind[p.adjusted<0.05] <- "I_1"
  Original_results$new_ind <- new_ind
  Original_results$p<-p
  Original_results$p.adjusted<-p.adjusted
  
  
  return(list(org_scaled=otu_scaled,
              Org_tax=Org_tax,
              p=p,
              p.adjusted=p.adjusted,
              Stat_Obs=stat.obs,
              Original_results=Original_results))
}
