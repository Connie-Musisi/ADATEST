#' Perform Permutation-Based Differential Abundance Testing
#'
#' This function computes a test statistic for each taxon in a microbiome dataset using estimated scores.
#' It then performs a permutation test to assess statistical significance and adjusts p-values for false discovery rate (FDR) control.
#'
#' @param data A phyloseq object containing filtered microbiome data (after TSS and trimming).
#' @param Train_parest A numeric vector of parameter estimates from the training data, used to compute the test statistic.
#' @param B Integer. Number of permutations to perform.  Passed from \code{ADATEST()}.
#' @param p.adjust.method Character string specifying the p-value adjustment method. Passed from \code{ADATEST()}.
#' @param group_var Character. The name of the grouping variable in the sample metadata.  Passed from \code{ADATEST()}.
#' @param group_levels Character vector of length two, specifying the two levels of \code{group_var} to be compared. Passed from \code{ADATEST()}.
#'
#' @return A list containing:
#' \item{org_scaled}{Scaled OTU table from the original dataset (after normalization).}
#' \item{Org_tax}{Original taxonomy table as a data frame.}
#' \item{p}{Vector of unadjusted p-values for each taxon.}
#' \item{p.adjusted}{Vector of adjusted p-values based on the selected method.}
#' \item{Stat_Obs}{Vector of observed test statistics.}
#' \item{Original_results}{Data frame combining test statistics, taxonomic info, p-values, adjusted p-values, and differential abundance indicators.}
#'
#' @details
#' The function computes the test statistic for each taxon based on estimated scores. 
#' The total sum scaling (TSS)-normalized counts in the original dataset are rescaled before test statistic computation.
#' Permutation-based null distributions are generated by permuting all taxa across the two groups while preserving their dependency structure.
#' The resulting raw p-values are adjusted to control the false discovery rate (FDR) using methods such as Benjamini-Hochberg or Storey's q-values.
#'
#' @import phyloseq
#' @import qvalue
#' @importFrom stats p.adjust
#' @export
Orig_Alz_Perm <- function(data, Train_parest, B,
                          p.adjust.method,
                          group_var,
                          group_levels){
  #set.seed(19)
  ############# Analyzing Original data ################
  org_data <- data
  Org_tax <- as.data.frame(tax_table(org_data))
  
  if(taxa_are_rows(org_data)){
    org_otu <- t(as.matrix(otu_table(org_data)))
  }else{
    org_otu <- as.matrix(otu_table(org_data))
  }
  samdata <- sample_data(data)[,group_var]
  n1 <- sum(samdata == group_levels[1])
  n2 <- sum(samdata == group_levels[2])
  
  n.taxa<-nrow(data@tax_table)
  
  tmp<-sapply(1:n.taxa, FUN=function(i) {
    d<-Normalize(org_otu[1:n1,i],
                 org_otu[(n1+1):(n1+n2),i])
    return(c(d$sample1,d$sample2))
  })
  otu1<-tmp[1:n1,]
  otu2<-tmp[(n1+1):(n1+n2),]
  otu_scaled<-rbind(otu1,otu2)
  
  
  stat.obs<-Test_Statistic(otu_scaled,Train_parest, n1=n1, n2=n2, B=B)
  set.seed(19)
  # Permutation null distributions
  nd<-matrix(nrow=B,ncol=n.taxa)
  for(i in 1:B) {
    perm_otu<-otu_scaled[sample(1:(n1+n2),(n1+n2),replace = FALSE),]
    nd[i,]<-Test_Statistic(perm_otu,Train_parest,n1=n1,n2=n2,B=B)
  }
  
  p<-sapply(1:n.taxa, function(i) {
    mean(nd[,i]>=stat.obs[i])
  })
  
  # P-value adjustment
  if(p.adjust.method == "qvalue"){
    check = tryCatch(qvalue(p=p)$qvalues, error = function(e) {
      return(NULL)
    })
    if(is.null(check)){p.adjusted <- qvalue(p=p,lambda=0)$qvalues}
    else{p.adjusted <-check}
    
  } else {
    p.adjusted <- p.adjust(p, method=p.adjust.method)
  }  
  colnames(stat.obs)<-"stat.obs"
  Original_results <- cbind(stat.obs,Org_tax)
  
  ## ----Results----------------------------------------------------------------------------------------------------------
  new_ind <- character(nrow(Original_results))
  new_ind[p.adjusted>=0.05] <- "I_0"
  new_ind[p.adjusted<0.05] <- "I_1"
  Original_results$new_ind <- new_ind
  Original_results$p<-p
  Original_results$p.adjusted<-p.adjusted
  
  return(list(org_scaled=otu_scaled,
              Org_tax=Org_tax,
              p=p,
              p.adjusted=p.adjusted,
              Stat_Obs=stat.obs,
              Original_results=Original_results))
}
